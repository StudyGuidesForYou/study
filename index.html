<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Modern Neon Physics</title>
<style>
    html, body {
        margin: 0;
        padding: 0;
        background: #000;
        height: 100%;
        overflow: hidden;
        font-family: system-ui, sans-serif;
        user-select: none;
    }

    #ui {
        position: fixed;
        top: 14px;
        left: 14px;
        z-index: 10;
        display: flex;
        flex-direction: column;
        gap: 8px;
    }

    button {
        background: rgba(30,30,30,0.9);
        color: white;
        padding: 10px 16px;
        border: 1px solid rgba(60,60,60,0.9);
        border-radius: 10px;
        font-size: 15px;
        cursor: pointer;
        transition: 0.15s;
    }
    button:hover {
        background: rgba(60,60,60,1);
    }

    canvas {
        display: block;
    }
</style>
</head>
<body>

<canvas id="c"></canvas>

<div id="ui">
    <button id="followBtn">Camera Follow: OFF</button>
    <button id="addBallBtn">Add Ball</button>
</div>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");

let W = window.innerWidth;
let H = window.innerHeight;
canvas.width = W;
canvas.height = H;

window.addEventListener("resize", () => {
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W;
    canvas.height = H;
    computeCircle();
});

// Circle boundary
let cx, cy, R;
function computeCircle() {
    cx = W / 2;
    cy = H / 2;
    R = Math.min(W, H) * 0.42;
}
computeCircle();

class Ball {
    constructor(x, y) {
        this.x = x;
        this.y = y;

        const angle = Math.random() * Math.PI * 2;
        const speed = 400 + Math.random() * 200;

        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;

        this.radius = 12;
        this.trail = [];

        this.hueOffset = Math.random() * 360;

        this.glow = 0;         // 0 = low glow, 1 = collision peak
        this.glowDecay = 0.92; // how fast glow returns to low
    }

    simulate(dt) {
        const substeps = 5;
        const step = dt / substeps;

        for (let i = 0; i < substeps; i++) {
            this.verlet(step);
            this.collisionCheck();
        }

        this.trail.push({ x: this.x, y: this.y });
        if (this.trail.length > 600) this.trail.shift();

        this.glow *= this.glowDecay;
    }

    verlet(dt) {
        this.x += this.vx * dt;
        this.y += this.vy * dt;
    }

    collisionCheck() {
        const dx = this.x - cx;
        const dy = this.y - cy;
        const dist = Math.hypot(dx, dy);
        const maxDist = R - this.radius;

        if (dist > maxDist) {
            const nx = dx / dist;
            const ny = dy / dist;

            this.x = cx + nx * maxDist;
            this.y = cy + ny * maxDist;

            const dot = this.vx * nx + this.vy * ny;
            this.vx -= 2 * dot * nx;
            this.vy -= 2 * dot * ny;

            this.glow = 1;
        }
    }

    drawTrail() {
        const len = this.trail.length;
        for (let i = 1; i < len; i++) {
            const p = this.trail[i];
            const hue = (i * 0.8 + this.hueOffset) % 360;

            const radius = this.radius;
            const alpha = i / len;

            ctx.fillStyle = `hsla(${hue}, 100%, 60%, ${alpha})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
            ctx.fill();
        }
    }

    drawBall() {
        ctx.shadowBlur = this.glow * 35;
        ctx.shadowColor = "white";

        ctx.fillStyle = `hsl(${this.hueOffset},100%,50%)`;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.shadowBlur = 0;
    }
}

let balls = [new Ball(cx, cy - R * 0.5)];

document.getElementById("addBallBtn").onclick = () => {
    balls.push(new Ball(cx, cy));
};

// Camera follow toggle
let follow = false;
document.getElementById("followBtn").onclick = () => {
    follow = !follow;
    document.getElementById("followBtn").textContent =
        "Camera Follow: " + (follow ? "ON" : "OFF");
};

function drawBoundary(glowLevel) {
    ctx.lineWidth = 6;
    ctx.strokeStyle = `rgba(0,255,120,${0.15 + glowLevel * 0.85})`;
    ctx.shadowBlur = 25 * glowLevel;
    ctx.shadowColor = "lime";

    ctx.beginPath();
    ctx.arc(cx, cy, R, 0, Math.PI * 2);
    ctx.stroke();

    ctx.shadowBlur = 0;
}

let last = performance.now();

function animate(now) {
    requestAnimationFrame(animate);
    const dt = Math.min((now - last) / 1000, 0.02);
    last = now;

    ctx.fillStyle = "black";
    ctx.fillRect(0, 0, W, H);

    if (follow) {
        const target = balls[0];
        const dx = cx - target.x;
        const dy = cy - target.y;
        ctx.save();
        ctx.translate(dx, dy);
    }

    let boundaryGlow = 0;

    for (let b of balls) {
        b.simulate(dt);
        if (b.glow > boundaryGlow) boundaryGlow = b.glow;
    }

    for (let b of balls) b.drawTrail();
    drawBoundary(boundaryGlow);
    for (let b of balls) b.drawBall();

    if (follow) ctx.restore();
}

requestAnimationFrame(animate);
</script>

</body>
</html>
