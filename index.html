<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Modern Embed Launcher</title>
<style>
  :root{
    --bg-deep:#040612; --bg-mid:#0a1526;
    --accent-a:#3dd3c7; --accent-b:#2b82ff;
    --text:#eaf2ff; --muted: rgba(230,235,255,0.48);
    --radius:18px; --max-width:1320px;
    --embed-min-w:320px; --embed-min-h:300px;
  }

  /* Base layout: always full-viewport */
  html,body{height:100%;width:100%;margin:0;padding:0;box-sizing:border-box;font-family:Inter,system-ui,Roboto,Arial;background:linear-gradient(180deg,var(--bg-deep),var(--bg-mid));-webkit-font-smoothing:antialiased;overflow:hidden;}

  /* Aurora - full-screen canvas behind everything */
  .aurora-wrap{position:fixed;inset:0;z-index:-10;pointer-events:none;display:block;}
  #auroraCanvas{width:100vw;height:100vh;display:block;filter:blur(48px) saturate(120%);opacity:0.95;transform:scale(1.02);} /* blur+scale for soft edges */

  /* Top bar */
  .top-bar{position:fixed;left:50%;transform:translateX(-50%);top:18px;z-index:30;width:min(var(--max-width),96%);display:flex;align-items:center;gap:12px;padding:6px 12px;}
  .url-box{flex:1;display:flex;gap:12px;align-items:center;}
  .url-input{flex:1;padding:12px 14px;border-radius:12px;border:none;background:rgba(255,255,255,0.02);color:var(--text);backdrop-filter:blur(8px);box-shadow:0 10px 30px rgba(2,6,14,0.6);font-size:15px}
  .enter-btn{padding:10px 14px;border-radius:10px;border:none;background:linear-gradient(135deg,var(--accent-a),var(--accent-b));color:#fff;font-weight:700;cursor:pointer;box-shadow:0 8px 24px rgba(43,130,255,0.12)}

  /* Embed card - fixed and centered by default */
  .embed-card{
    position:fixed;
    left:50%;
    top:50%;
    transform:translate(-50%,-50%); /* centered until user drags */
    width:80vw;
    max-width:1100px;
    min-width:var(--embed-min-w);
    height:70vh;
    min-height:var(--embed-min-h);
    border-radius:var(--radius);
    overflow:hidden;
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border:1px solid rgba(255,255,255,0.035);
    box-shadow:0 30px 80px rgba(2,6,18,0.7);
    z-index:40;
    display:flex;
    flex-direction:column;
    touch-action:none;
    transition:box-shadow .18s, transform .12s;
  }
  .embed-card.dragging{transition:none;box-shadow:0 40px 120px rgba(2,6,18,0.82);}

  /* iframe fills */
  .embed-iframe{width:100%;height:100%;border:0;background:#fff;flex:1;display:block;}

  /* controls */
  .embed-controls{position:absolute;top:12px;right:12px;display:flex;gap:8px;z-index:60;}
  .control-btn{width:36px;height:36px;border-radius:8px;border:none;background:rgba(255,255,255,0.04);color:white;display:flex;align-items:center;justify-content:center;cursor:pointer;font-size:16px}
  .control-btn:hover{background:rgba(255,255,255,0.12)}

  /* resize handle bottom-right */
  .resize-handle{position:absolute;right:8px;bottom:8px;width:20px;height:20px;cursor:se-resize;z-index:60;background:linear-gradient(180deg,rgba(255,255,255,0.03),rgba(255,255,255,0.01));border-radius:4px;box-shadow:inset 0 -2px 6px rgba(0,0,0,0.35);}

  /* games list */
  .games{position:fixed;left:50%;transform:translateX(-50%);bottom:18px;z-index:30;width:min(var(--max-width),96%);display:flex;justify-content:center}
  .game-list{display:flex;gap:10px;flex-wrap:wrap;justify-content:center}
  .game-btn{padding:8px 12px;border-radius:999px;background:rgba(255,255,255,0.02);border:1px solid rgba(255,255,255,0.04);color:var(--text);cursor:pointer;font-weight:600;backdrop-filter:blur(6px)}

  /* small responsive tweaks */
  @media (max-width:900px){
    .embed-card{width:92vw;height:62vh}
    .top-bar{top:12px}
    .games{bottom:12px}
  }
  @media (max-width:480px){
    .embed-card{width:96vw;height:56vh}
    .url-input{font-size:14px}
  }
</style>
</head>
<body>

  <!-- Aurora -->
  <div class="aurora-wrap"><canvas id="auroraCanvas"></canvas></div>

  <!-- Top search -->
  <header class="top-bar" role="search">
    <div class="url-box">
      <input id="urlInput" class="url-input" placeholder="Enter URL (example: slowroads.io)" aria-label="URL to embed">
      <button id="enterBtn" class="enter-btn">Enter</button>
    </div>
  </header>

  <!-- Embed card (centered by default) -->
  <div id="embedCard" class="embed-card" role="region" aria-label="Embed area">
    <div class="embed-controls" aria-hidden="true">
      <button id="fullscreenBtn" class="control-btn" title="Fullscreen">⤢</button>
      <button id="redirectBtn" class="control-btn" title="Open in new tab">↗</button>
    </div>

    <div id="loader" class="loader" aria-hidden="true" style="pointer-events:none;display:flex;align-items:center;justify-content:center;position:absolute;inset:0;z-index:50;background:rgba(6,10,20,0.24);backdrop-filter:blur(6px)">
      <div style="display:flex;flex-direction:column;align-items:center;gap:8px">
        <div style="width:64px;height:64px;border-radius:50%;border:8px solid rgba(255,255,255,0.08);border-top-color:var(--accent-b);animation:spin 1s linear infinite;box-shadow:0 8px 28px rgba(43,130,255,0.12)"></div>
        <div style="color:var(--muted);font-size:13px">Loading…</div>
      </div>
    </div>

    <!-- iframe: NOTE sandbox purposely excludes allow-same-origin for safety -->
    <iframe id="embedFrame" class="embed-iframe" src="about:blank" sandbox="allow-scripts allow-forms allow-modals allow-popups"></iframe>

    <div id="resizeHandle" class="resize-handle" aria-hidden="true"></div>
  </div>

  <!-- Games -->
  <section class="games" aria-label="Games list">
    <div class="game-list" role="list">
      <button class="game-btn" data-url="https://slowroads.io">slowroads.io</button>
      <button class="game-btn" data-url="https://bloxd.io">bloxd.io</button>
      <button class="game-btn" data-url="https://diep.io">diep.io</button>
      <button class="game-btn" data-url="https://sandboxels.r74n.com">sandboxels</button>
      <button class="game-btn" data-url="https://jellymar.io">jellymar.io</button>
      <button class="game-btn" data-url="https://gamesnacks.com">gamesnacks</button>
      <button class="game-btn" data-url="https://adarkroom.doublespeakgames.com">adarkroom</button>
      <button class="game-btn" data-url="https://eaglercraft.com">eaglercraft</button>
      <button class="game-btn" data-url="https://ev.io">ev.io</button>
      <button class="game-btn" data-url="https://play.gidd.io">gidd.io</button>
      <button class="game-btn" data-url="https://html5games.com/">html5games</button>
      <button class="game-btn" data-url="https://dd-student-dash.educationate.space.cdn.cloudflare.net/indev">Browser</button>
    </div>
  </section>

<script>
/* -------------------------
   Helper / Debug logger
   ------------------------- */
function logDbg(...args){ console.log("[EmbedLauncher " + new Date().toLocaleTimeString() + "]", ...args); }

/* -------------------------
   Aurora - high-quality ovals
   ------------------------- */
const canvas = document.getElementById('auroraCanvas');
const ctx = canvas.getContext('2d', {alpha:true});
let W = canvas.width = window.innerWidth;
let H = canvas.height = window.innerHeight;
window.addEventListener('resize', ()=>{ W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; });

/* Create layered ovals with additive blending for rich aurora */
class Oval {
  constructor(){ this.reset(); }
  reset(){
    this.x = Math.random()*W;
    this.y = Math.random()*H;
    this.w = 350 + Math.random()*700;
    this.h = 100 + Math.random()*400;
    this.hue = 150 + Math.random()*80; // green-blue range
    this.alpha = 0.06 + Math.random()*0.14;
    this.vx = 0.02 + Math.random()*0.15;
    this.vy = (Math.random()-0.5) * 0.06;
    this.drift = (Math.random()<0.5?-1:1) * (0.005 + Math.random()*0.02);
  }
  update(){
    this.x -= this.vx;
    this.y += this.vy;
    this.hue += this.drift;
    if(this.hue > 220) this.hue = 150;
    if(this.hue < 150) this.hue = 220;
    if(this.x < -this.w) this.x = W + this.w;
    if(this.y < -this.h) this.y = H + this.h;
    if(this.y > H + this.h) this.y = -this.h;
  }
  draw(){
    const g = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.w);
    g.addColorStop(0, `hsla(${this.hue}, 85%, 56%, ${this.alpha})`);
    g.addColorStop(0.6, `hsla(${this.hue + 20}, 78%, 45%, ${this.alpha*0.7})`);
    g.addColorStop(1, `hsla(200,40%,10%,0)`);
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = g;
    ctx.beginPath();
    ctx.ellipse(this.x, this.y, this.w, this.h, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalCompositeOperation = 'source-over';
  }
}

const ovals = Array.from({length:12}, ()=> new Oval());
let auroraTick = 0;
function animateAurora(){
  auroraTick++;
  // subtle background wash so the blur has something to blend with
  ctx.clearRect(0,0,W,H);
  // draw a faint radial dark-to-deep layer first for depth
  const bg = ctx.createLinearGradient(0,0,W,H);
  bg.addColorStop(0, 'rgba(4,10,20,0.25)');
  bg.addColorStop(1, 'rgba(2,6,14,0.4)');
  ctx.fillStyle = bg; ctx.fillRect(0,0,W,H);

  // draw ovals with slow updates
  for (let i=0;i<ovals.length;i++){
    const o = ovals[i];
    o.update();
    o.draw();
  }

  // very subtle global hue shift overlay (makes movement feel alive)
  if (auroraTick % 300 === 0) logDbg("Aurora running - tick", auroraTick);
  requestAnimationFrame(animateAurora);
}
requestAnimationFrame(animateAurora);

/* -------------------------
   Embed / iframe logic
   ------------------------- */
const embedCard = document.getElementById('embedCard');
const iframe = document.getElementById('embedFrame');
const loader = document.getElementById('loader');
const urlInput = document.getElementById('urlInput');
const enterBtn = document.getElementById('enterBtn');
const fullscreenBtn = document.getElementById('fullscreenBtn');
const redirectBtn = document.getElementById('redirectBtn');
const resizeHandle = document.getElementById('resizeHandle');

logDbg("Init sizes", window.innerWidth, window.innerHeight);

/* Helpers */
function clamp(n, a, b){ return Math.max(a, Math.min(b, n)); }
function showLoader(){ loader.style.display = 'flex'; loader.style.opacity = '1'; logDbg('Loader shown'); }
function hideLoader(){ loader.style.opacity = '0'; setTimeout(()=>{ loader.style.display='none'; }, 300); logDbg('Loader hidden'); }
function normalizeUrl(raw){
  raw = (raw||'').trim();
  if(!raw) return null;
  try{
    if(!/^https?:\/\//i.test(raw)) raw = 'https://'+raw;
    new URL(raw);
    return raw;
  }catch(e){ return null; }
}

/* Load URL into iframe (safe sandbox without allow-same-origin) */
function loadUrl(url){
  if(!url) return;
  showLoader();
  iframe.src = url;
  logDbg('Loading URL', url);
}

/* Buttons and input */
enterBtn.addEventListener('click', ()=> {
  const url = normalizeUrl(urlInput.value);
  if(!url){ urlInput.focus(); urlInput.animate([{transform:'translateY(0)'},{transform:'translateY(-6px)'},{transform:'translateY(0)'}],{duration:220}); logDbg('Invalid URL'); return; }
  loadUrl(url);
});
urlInput.addEventListener('keydown', (e)=>{ if(e.key === 'Enter') enterBtn.click(); });

document.querySelectorAll('.game-btn').forEach(b=>{
  b.addEventListener('click', ()=> {
    const url = normalizeUrl(b.dataset.url);
    if(!url) return;
    loadUrl(url);
  });
});

/* Iframe events */
iframe.addEventListener('load', ()=> { hideLoader(); logDbg('iframe loaded', iframe.src); });
iframe.addEventListener('error', ()=> { hideLoader(); logDbg('iframe error', iframe.src); });

/* Fullscreen: make the iframe visible fullscreen by requesting fullscreen on the embedCard */
fullscreenBtn.addEventListener('click', ()=> {
  if(embedCard.requestFullscreen) embedCard.requestFullscreen();
  else if(embedCard.webkitRequestFullscreen) embedCard.webkitRequestFullscreen();
  logDbg('Requested fullscreen');
});

/* Redirect to actual page */
redirectBtn.addEventListener('click', ()=> {
  if(iframe.src && iframe.src !== 'about:blank') window.open(iframe.src, '_blank');
  logDbg('Redirect clicked', iframe.src);
});

/* -------------------------
   Center-lock + Dragging
   - Card starts centered (transform used).
   - When user mouses down (drag), release transform and set left/top.
   - Clamp movement to viewport.
   ------------------------- */
let isDragging = false;
let dragOffsetX = 0, dragOffsetY = 0;
let wasCentered = true; // indicates transform center mode active

function releaseCenteringAndSetLeftTop(){
  if(!wasCentered) return;
  // compute current pixel-centered left/top from transform
  const rect = embedCard.getBoundingClientRect();
  // convert transform center to explicit left/top (current center)
  const leftPx = rect.left;
  const topPx = rect.top;
  // remove transform and set left/top in px
  embedCard.style.transform = 'none';
  embedCard.style.left = `${leftPx}px`;
  embedCard.style.top = `${topPx}px`;
  wasCentered = false;
  logDbg('Centering released; switching to absolute left/top.');
}

embedCard.addEventListener('pointerdown', (e)=>{
  // ignore if user clicked the resize handle or controls
  const target = e.target;
  if(target === resizeHandle || target.closest('.embed-controls')) return;
  e.preventDefault();
  // release centering on first drag
  releaseCenteringAndSetLeftTop();
  isDragging = true;
  embedCard.classList.add('dragging');
  const rect = embedCard.getBoundingClientRect();
  dragOffsetX = e.clientX - rect.left;
  dragOffsetY = e.clientY - rect.top;
  logDbg('Drag start', {left: rect.left, top: rect.top, w: rect.width, h: rect.height});
  // capture pointer for smooth dragging
  embedCard.setPointerCapture?.(e.pointerId);
});

window.addEventListener('pointermove', (e)=>{
  if(!isDragging) return;
  e.preventDefault();
  // clamp so card stays fully visible
  const cardW = embedCard.offsetWidth;
  const cardH = embedCard.offsetHeight;
  const minLeft = 8;
  const maxLeft = window.innerWidth - cardW - 8;
  const minTop = 8;
  const maxTop = window.innerHeight - cardH - 8;
  let left = e.clientX - dragOffsetX;
  let top = e.clientY - dragOffsetY;
  left = clamp(left, minLeft, Math.max(minLeft, maxLeft));
  top  = clamp(top, minTop, Math.max(minTop, maxTop));
  embedCard.style.left = `${left}px`;
  embedCard.style.top  = `${top}px`;
});

window.addEventListener('pointerup', (e)=>{
  if(isDragging){
    isDragging = false;
    embedCard.classList.remove('dragging');
    embedCard.releasePointerCapture?.(e.pointerId);
    logDbg('Drag end', {left: embedCard.style.left, top: embedCard.style.top});
  }
});

/* -------------------------
   Resizing with constraints
   ------------------------- */
let isResizing = false;
let resizeStartW = 0, resizeStartH = 0, resizeStartX = 0, resizeStartY = 0;
resizeHandle.addEventListener('pointerdown', (e)=>{
  e.preventDefault(); e.stopPropagation();
  releaseCenteringAndSetLeftTop();
  isResizing = true;
  resizeStartW = embedCard.offsetWidth;
  resizeStartH = embedCard.offsetHeight;
  resizeStartX = e.clientX;
  resizeStartY = e.clientY;
  embedCard.classList.add('dragging');
  logDbg('Resize start', {w:resizeStartW,h:resizeStartH});
  resizeHandle.setPointerCapture?.(e.pointerId);
});

window.addEventListener('pointermove', (e)=>{
  if(!isResizing) return;
  e.preventDefault();
  const dx = e.clientX - resizeStartX;
  const dy = e.clientY - resizeStartY;
  let newW = Math.max(parseInt(getComputedStyle(embedCard).minWidth || 320), resizeStartW + dx);
  let newH = Math.max(parseInt(getComputedStyle(embedCard).minHeight || 300), resizeStartH + dy);
  // clamp to viewport so it never grows off-screen
  const leftPx = wasCentered ? (window.innerWidth - newW) / 2 : parseFloat(embedCard.style.left || 0);
  const topPx  = wasCentered ? (window.innerHeight - newH) / 2 : parseFloat(embedCard.style.top || 0);
  newW = Math.min(newW, window.innerWidth - 16);      // 8px padding left/right
  newH = Math.min(newH, window.innerHeight - 16);     // 8px padding top/bottom
  embedCard.style.width = `${newW}px`;
  embedCard.style.height = `${newH}px`;
  // after resize, ensure position still clamped
  const maxLeft = window.innerWidth - newW - 8;
  const maxTop  = window.innerHeight - newH - 8;
  if(!wasCentered){
    let curLeft = parseFloat(embedCard.style.left || 0);
    let curTop  = parseFloat(embedCard.style.top  || 0);
    curLeft = clamp(curLeft, 8, Math.max(8, maxLeft));
    curTop  = clamp(curTop, 8, Math.max(8, maxTop));
    embedCard.style.left = curLeft + 'px';
    embedCard.style.top  = curTop  + 'px';
  } else {
    // if still centered, keep it visually centered by adjusting left/top when transform removed
    embedCard.style.left = ((window.innerWidth - newW)/2) + 'px';
    embedCard.style.top  = ((window.innerHeight - newH)/2) + 'px';
  }
});

window.addEventListener('pointerup', (e)=>{
  if(isResizing){
    isResizing = false;
    embedCard.classList.remove('dragging');
    resizeHandle.releasePointerCapture?.(e.pointerId);
    logDbg('Resize end', {w:embedCard.offsetWidth, h:embedCard.offsetHeight, left:embedCard.style.left, top:embedCard.style.top});
  }
});

/* -------------------------
   Keep centered on window resize (only if not dragged)
   ------------------------- */
window.addEventListener('resize', ()=> {
  if(wasCentered){
    // keep transform centered; nothing needed because transform centers
    logDbg('Window resized - still center-locked');
  } else {
    // if card is positioned absolute, clamp within new viewport
    const w = embedCard.offsetWidth, h = embedCard.offsetHeight;
    const left = parseFloat(embedCard.style.left || 0);
    const top  = parseFloat(embedCard.style.top || 0);
    const clampedLeft = clamp(left, 8, Math.max(8, window.innerWidth - w - 8));
    const clampedTop  = clamp(top, 8, Math.max(8, window.innerHeight - h - 8));
    embedCard.style.left = clampedLeft + 'px';
    embedCard.style.top  = clampedTop  + 'px';
    logDbg('Window resized - clamped card to viewport');
  }
});

/* -------------------------
   Initial safety: ensure embed card visible (unclipped)
   ------------------------- */
(function ensureVisibleOnStart(){
  // quick clamp and center to viewport
  const w = embedCard.offsetWidth, h = embedCard.offsetHeight;
  const left = (window.innerWidth - w) / 2;
  const top  = (window.innerHeight - h) / 2;
  embedCard.style.left = left + 'px';
  embedCard.style.top  = top + 'px';
  // keep transform for perfect centering (we set left/top but transform still used)
  wasCentered = true;
  logDbg('Initial embed position set and center-locked');
})();

/* -------------------------
   Safety notes in console
   ------------------------- */
logDbg('Sandbox used: allow-scripts, allow-forms, allow-modals, allow-popups (NO allow-same-origin)');

</script>
</body>
</html>
