<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Advanced Ball Sim</title>
<style>
  body {
    margin: 0;
    background: black;
    color: white;
    font-family: Arial, sans-serif;
    overflow: hidden;
  }
  #ui {
    position: fixed;
    top: 10px;
    right: 10px;
    background: rgba(20,20,20,0.7);
    padding: 15px;
    border-radius: 12px;
    backdrop-filter: blur(10px);
  }
  button, select, input {
    width: 150px;
    margin: 5px 0;
    padding: 6px;
    font-size: 15px;
    border-radius: 8px;
    border: none;
    background: #222;
    color:white;
    cursor: pointer;
  }
  #combineModes {
    margin-top: 10px;
    display: flex;
    flex-direction: column;
  }
  label {
    font-size: 14px;
    margin: 2px 0;
  }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="ui">
  <button id="addBallBtn">Add Ball</button>
  <button id="toggleCamBtn">Toggle Cam Follow</button>
  <select id="mode">
    <option value="none">Low Quality (No Gravity)</option>
    <option value="gravity">Gravity</option>
    <option value="blackhole">Gravity Ball</option>
    <option value="double">Double Trouble</option>
  </select>
  <div id="combineModes">
    <label><input type="checkbox" value="gravity"> Gravity</label>
    <label><input type="checkbox" value="blackhole"> Gravity Ball</label>
    <label><input type="checkbox" value="double"> Double Trouble</label>
  </div>
</div>
<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
let w, h, cx, cy, radius;

function resize(){
  w = canvas.width = window.innerWidth;
  h = canvas.height = window.innerHeight;
  cx = w/2; cy = h/2;
  radius = Math.min(w,h)*0.4;
}
window.onresize = resize; resize();

class Ball{
  constructor(){
    this.reset();
  }
  reset(){
    this.x = cx + (Math.random()*2-1)*50;
    this.y = cy + (Math.random()*2-1)*50;
    const a = Math.random()*Math.PI*2;
    const s = 3 + Math.random()*2;
    this.vx = Math.cos(a)*s;
    this.vy = Math.sin(a)*s;
    this.trail=[];
  }
  update(){
    const modes = getActiveModes();

    // Gravity downward
    if(modes.includes("gravity")){
      this.vy += 0.3; // stronger gravity
    }

    // Black hole gravity
    if(modes.includes("blackhole")){
      const dx = blackhole.x - this.x;
      const dy = blackhole.y - this.y;
      const d = Math.sqrt(dx*dx + dy*dy);
      const g = Math.min(50, 2000/(d*d+50));
      this.vx += dx/d*g;
      this.vy += dy/d*g;
    }

    // Apply velocity damping
    this.vx *= 0.995;
    this.vy *= 0.995;

    // Update position
    this.x += this.vx;
    this.y += this.vy;

    // Circle boundary collision (bounce)
    const dx = this.x - cx;
    const dy = this.y - cy;
    const dist = Math.sqrt(dx*dx + dy*dy);
    if(dist > radius){
      const nx = dx/dist;
      const ny = dy/dist;
      const dot = this.vx*nx + this.vy*ny;
      this.vx -= 2*dot*nx;
      this.vy -= 2*dot*ny;
      // damping on bounce
      this.vx *= 0.9;
      this.vy *= 0.9;

      if(modes.includes("double")){
        let current = balls.length;
        for(let i=0;i<current;i++){
          spawnBall();
        }
      }
    }

    // Trail
    this.trail.push({x:this.x,y:this.y});
    if(this.trail.length>50) this.trail.shift();
  }
  draw(){
    for(let i=1;i<this.trail.length;i++){
      const p = this.trail[i];
      ctx.beginPath();
      ctx.arc(p.x,p.y,3,0,Math.PI*2);
      ctx.fillStyle=`hsla(${i*5},100%,50%,0.3)`;
      ctx.fill();
    }
    ctx.beginPath();
    ctx.arc(this.x,this.y,10,0,Math.PI*2);
    ctx.fillStyle = "lime";
    ctx.fill();
    // Add subtle glow
    ctx.shadowColor = "lime";
    ctx.shadowBlur = 10;
    ctx.fill();
    ctx.shadowBlur = 0;
  }
}

let balls=[new Ball()];
function spawnBall(){balls.push(new Ball());}

let camFollow=false;
let modeSel=document.getElementById("mode");
const combineCheckboxes = document.querySelectorAll("#combineModes input");

// Black hole
const blackhole={angle:0,x:0,y:0};

// Mode reset
modeSel.onchange = ()=>{
  balls=[new Ball()];
  updateCheckboxesFromSelect();
}

// Combine checkbox logic
combineCheckboxes.forEach(cb=>{
  cb.addEventListener("change", ()=>{
    // turn off conflicting modes
    combineCheckboxes.forEach(other=>{
      if(other!==cb) other.checked=false;
    });
    // update dropdown to match
    modeSel.value = cb.checked ? cb.value : "none";
    balls=[new Ball()];
  });
});

// helper: get active modes from checkboxes
function getActiveModes(){
  return Array.from(combineCheckboxes).filter(cb=>cb.checked).map(cb=>cb.value);
}

function updateCheckboxesFromSelect(){
  combineCheckboxes.forEach(cb=>{
    cb.checked = cb.value === modeSel.value;
  });
}

function loop(){
  requestAnimationFrame(loop);
  ctx.clearRect(0,0,w,h);

  const modes = getActiveModes();

  // Black hole orbit
  if(modes.includes("blackhole")){
    blackhole.angle += 0.01;
    blackhole.x = cx + Math.cos(blackhole.angle)*(radius+50);
    blackhole.y = cy + Math.sin(blackhole.angle)*(radius+50);

    let grad = ctx.createRadialGradient(blackhole.x,blackhole.y,5,blackhole.x,blackhole.y,35);
    grad.addColorStop(0,"white");
    grad.addColorStop(0.5,"cyan");
    grad.addColorStop(1,"rgba(0,255,255,0)");
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(blackhole.x,blackhole.y,20,0,Math.PI*2);
    ctx.fill();
  }

  // Camera
  let camX=0, camY=0;
  if(camFollow && balls.length>0){
    camX = cx - balls[0].x;
    camY = cy - balls[0].y;
  }
  ctx.save();
  ctx.translate(camX, camY);

  // Outer circle
  ctx.beginPath();
  ctx.arc(cx, cy, radius, 0, Math.PI*2);
  ctx.strokeStyle="rgba(0,255,0,0.5)";
  ctx.lineWidth=5;
  ctx.stroke();

  // Update & draw all balls
  for(const b of balls){ b.update(); b.draw(); }

  ctx.restore();
}
loop();

// UI buttons
document.getElementById("addBallBtn").onclick = ()=>spawnBall();
document.getElementById("toggleCamBtn").onclick = ()=>camFollow = !camFollow;
</script>
</body>
</html>
